---
title: 深拷贝与浅拷贝
tags: Java
grammar_cjkRuby: true
---

## 创建对象的方式

1、调用new语句创建对象，最常见的一种
2、运用反射手段创建对象,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法
3、调用对象的clone()方法
4、使用反序列化,调用java.io.ObjectInputStream 对象的 readObject()方法.

## 将一个对象的引用复制给另外一个对象的方法

1、直接赋值
2、浅拷贝
3、深拷贝

### 直接赋值
实体类Person.java
```
public class Person {
    //姓名
    private String name;
    // 年龄
    private int age;
    // 编号
    private Integer code;


    public Person(String name, int age, Integer code) {
        this.name = name;
        this.age = age;
        this.code = code;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

}
```
测试类cloneDemo.java

本篇所有测试均会在该类下完成
```
public class cloneDemo {
    public static void main(String[] args) {
        Person p = new Person("小明",11,123);
        Person p1 = p;
        System.out.println(p);
        System.out.println(p1);
    }
}
```
打印结果：
```
Others.base.cloneDemo.Person@4554617c
Others.base.cloneDemo.Person@4554617c
```
两者打印出来的地址相同，可见二者的引用是同一个对象，并没有创建出一个新的对象。可以把这种现象叫做引用的复制（或引用拷贝）。

对Person.java追加toString方法，
```
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", code=" + code +
                '}';
    }
```
cloneDemo.java中追加
```
        p1.setCode(1234);
        System.out.println("------------------");
        System.out.println(p);
        System.out.println(p1);
```
从打印结果中更能体现出这一点,因为是同一个对象的引用，所以两者改一个，另一个对象的值也随之改变：
```
Person{name='小明', age=11, code=123}
Person{name='小明', age=11, code=123}
------------------
Person{name='小明', age=11, code=1234}
Person{name='小明', age=11, code=1234}
```
