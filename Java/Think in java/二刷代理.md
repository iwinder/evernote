## 动态代理
在使用动态代理时，需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，该类被要求实现InvocationHandler接口。

当调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中。参数proxy为调用method的代理实例(即动态生成的那个代理类)，method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
```

一个典型的动态代理可分为以下四个步骤：

- 创建抽象角色（如：Animal）
- 创建真实角色(如：Dog)
- 通过实现InvocationHandler接口创建中介类（如：DynamicProxyHandler）
- 通过场景类，动态生成代理类（如：SimpleDynamicProxy）


在场景类中通过如下代码动态产生了一个代理类，并返回了其实例：
```java
    Animal prox = (Animal) Proxy.newProxyInstance(
            Animal.class.getClassLoader(),
            new Class[]{Animal.class},
            new DynamicProxyHandler(dog)
    );
```

Proxy的newProxyInstance主要业务逻辑为：

```java
// 1 获得与传入的指定类装载器（loader）和接口列表（intfs）相关的代理类类型对象，亦既生成代理类class,并加载到JVM中
Class<?> cl = getProxyClass0(loader, intfs);
// 2 通过反射获取该代理类的构造函数，亦既获取代理类的参数类型为InvocationHandler的构造函数
final Constructor<?> cons = cl.getConstructor(constructorParams);
// 3 返回这个新的代理类的一个实例，亦既生成并返回代理类实例
return cons.newInstance(new Object[]{h});
```

具体做的事有:

- 根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即Animal接口的doBark方法和somethingElse方法。假设动态生成的类为$Proxy0。
- 通过传入的classloder（该例中即Animal.class.getClassLoader()）,将刚生成的$Proxy0类加载到jvm中。
- 利用中介类，调用$Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。

其核心为getProxyClass0方法。

```java
    /**
     * Generate a proxy class.  Must call the checkProxyAccess method
     * to perform permission checks before calling this.
     */
    private static Class<?> getProxyClass0(ClassLoader loader,
                                           Class<?>... interfaces) {
        // 校验接口数量
        if (interfaces.length > 65535) {
            throw new IllegalArgumentException("interface limit exceeded");
        }
        // 从缓存中获取，如果没有就通过ProxyClassFactory创建
        // If the proxy class defined by the given loader implementing
        // the given interfaces exists, this will simply return the cached copy;
        // otherwise, it will create the proxy class via the ProxyClassFactory
        return proxyClassCache.get(loader, interfaces);
    }
```

[说说 JAVA 代理模式](http://www.importnew.com/26116.html)

[Java的三种代理模式](https://www.cnblogs.com/cenyu/p/6289209.html)

[java经典讲解-静态代理和动态代理的区别](https://blog.csdn.net/fangqun663775/article/details/78960545)

[Java三种代理模式：静态代理、动态代理和cglib代理](https://segmentfault.com/a/1190000011291179)

### 扩展

[6. 代理模式](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html)

[Java动态代理机制详解](https://blog.csdn.net/w05980598/article/details/79491627)

[Java 8动态代理的新技巧（1）：为什么使用动态代理？](http://www.importnew.com/16670.html)

[Java Proxy 和 CGLIB 动态代理原理](http://www.importnew.com/27772.html)

[有点深度的聊聊JDK动态代理](https://juejin.im/post/5c637cc4f265da2dd773c3d6)