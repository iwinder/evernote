队列同步器AbstractQueuedSynchronizer(AQS)是用来构建锁或者其他同步组件的基础框架。该类也是其他许多同步类的基类，许多同步器通过AQS很容易构造出来（如，ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock等，Java6以前的版本还包含SynchronousQueue和FutureTask）。

AQS解决了在实现同步器时涉及的大佬细节问题，如获取同步状态，等待线程采用FIFO队列操作顺序。

基于AQS来构建同步器能带来许多好处。不仅能**极大地减少实现工作**，而且也**不必处理在多个位置上发生的竞争问题**（这是在没有使用AQS来构建同步器时的情况）。

在**基于AQS构建的同步器中，只可能在一个时刻发生非阻塞，从而降低了上下文切换的开销，并提高吞吐量**。在设计AQS时充分考虑了可伸缩性，因此java.util.concurrent中所有基于AQS构建的同步器都能获得这个优势。

AQS使用了一个**int成员变量**表示**同步状态**，通过内置的**FIFO队列**来完成资源**获取线程的排队工作**，并发包的作者Doug Lea期望它能成为实现大部分同步需求的基础。

## 同步器主要使用方式是继承

子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要对同步状态进行改变，此时需要使用同步器提供的3个方法来进行操作：
- 1.getState()
- 2.setState(int newState)
- 3.compareAndSetState(int expect, int update)
因为它们能**保证状态的改变是线程安全的**。

子类**推荐被定义为自定义同步组件的静态内部类**，**同步器**自身没有实现任何同步接口，它**仅是定义了若干同步状态获取和释放的方法**来供自定义同步组件使用，**同步器既可以支持独占式的获取同步状态，也可以支持共享式地获取同步状态**，这样就可以方便实现不同类型的同步组件。


同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以如下理解两者的关系：
- 锁时面向使用者的，定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节。
- 同步器面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。